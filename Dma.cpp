#include "Dma.hpp"
#include "Reg.hpp"

enum {
    DMACON = 0xBF808900,
        ON = 1<<15,
        SUSPEND = 1<<12,
        DMABUSY = 1<<11,
    DMASTAT = 0xBF808910,
        RDWR = 1<<3,
        DMACH_SHIFT = 0, DMACH_CLR = 7,
    DMAADDR = 0xBF808920,
    DCRCCON = 0xBF808930,
        BYTO_SHIFT = 28, BYTO_CLR = 3,
        WBO = 1<<27,
        BITO = 1<<24,
        PLEN_SHIFT = 8, PLEN_CLR = 31,
        CRCEN = 1<<7,
        CRCAPP = 1<<6,
        CRCTYP = 1<<5,
        CRCCH_SHIFT = 0, CRCCH_CLR = 7,
    DCRCDATA = 0xBF808940,
    DCRCXOR = 0xBF808950,
    DCH0CON = 0xBF808960, DCH_SPACING = 0x30, //spacing in words
        CHBUSY = 1<<15,
        CHCHNS = 1<<8,
        CHEN = 1<<7,
        CHAED = 1<<6,
        CHCHN = 1<<5,
        CHAEN = 1<<4,
        CHEDET = 1<<2,
        CHPRI_SHIFT = 0, CHPRI_CLR = 3,
    //register offsets from base in words
    //(m_dmax_con is pointer, so addition will be in words)
    DCHXECON = 4,
        CHAIRQ_SHIFT = 16, CHAIRG_CLR = 255, //can use byte access
        CHSIRQ_SHIFT = 8, CHSIRQ_CLR = 255, //can use byte access
        CFORCE = 1<<7,
        CABORT = 1<<6,
        PATEN = 1<<5,
        SIRQEN = 1<<4,
        AIRQEN = 1<<3,
    DCHXINT = 8,
        CHSDIE = 1<<23,
        CHSHIE = 1<<22,
        CHDDIE = 1<<21,
        CHDHIE = 1<<20,
        CHBCIE = 1<<19,
        CHCCIE = 1<<18,
        CHTAIE = 1<<17,
        CHERIE = 1<<16,
        CHSDIF = 1<<7,
        CHSHIF = 1<<6,
        CHDDIF = 1<<5,
        CHDHIF = 1<<4,
        CHBCIF = 1<<3,
        CHCCIF = 1<<2,
        CHTAIF = 1<<1,
        CHERIF = 1<<0,
    DCHXSSA = 12,
    DCHXDSA = 16,
    DCHXSSIZ = 20,
    DCHXDSIZ = 24,
    DCHXSPTR = 28,
    DCHXDPTR = 32,
    DCHXCSIZ = 36,
    DCHXCPTR = 40,
    DCHXDAT = 44
};

using vu8ptr = volatile uint8_t*;            //access reg as bytes

//=============================================================================
                    Dma::Dma            (DMAX e)
//=============================================================================
    : m_dmax_con((volatile uint32_t*)DCH0CON + (e * DCH_SPACING))
{
}

//common static functions
//DMACON
//=============================================================================
    void            Dma::all_on         (bool tf)
//=============================================================================
{
    Reg::setbit(DMACON, ON, tf);
}

//=============================================================================
    void            Dma::all_suspend    (bool tf)
//=============================================================================
{
    Reg::setbit(DMACON, SUSPEND, tf);
}

//=============================================================================
    bool            Dma::all_suspend    ()
//=============================================================================
{
    return Reg::anybit(DMACON, SUSPEND);
}

//=============================================================================
    bool            Dma::any_busy       ()
//=============================================================================
{
    return Reg::anybit(DMACON, DMABUSY);
}

//DMASTAT
//=============================================================================
    bool            Dma::last_rd        ()
//=============================================================================
{
    return Reg::anybit(DMASTAT, RDWR);
}

//=============================================================================
    uint8_t         Dma::last_ch        ()
//=============================================================================
{
    return Reg::val8(DMASTAT) bitand DMACH_CLR;
}

//DMAADDR
//=============================================================================
    uint32_t        Dma::last_addr      ()
//=============================================================================
{
    return Reg::val(DMAADDR);
}

//DCRCCON
//=============================================================================
    void            Dma::crc_byto       (CRCBYTO e)
//=============================================================================
{
    Reg::clrbit(DCRCCON, BYTO_CLR<<BYTO_SHIFT);
    Reg::setbit(DCRCCON, e<<BYTO_SHIFT);
    Reg::setbit(DCRCCON, WBO, (bool)e);
}

//=============================================================================
    void            Dma::crc_bito       (CRCBITO e)
//=============================================================================
{
    Reg::setbit(DCRCCON, BITO, e);
}

//=============================================================================
    void            Dma::crc_polyn      (uint8_t v)
//=============================================================================
{
    Reg::clrbit(DCRCCON, PLEN_CLR<<PLEN_SHIFT);
    Reg::setbit(DCRCCON, (v bitand PLEN_CLR)<<PLEN_SHIFT);
}

//=============================================================================
    void            Dma::crc_on         (bool tf)
//=============================================================================
{
    Reg::setbit(DCRCCON, CRCEN, tf);
}

//=============================================================================
    void            Dma::crc_append     (bool tf)
//=============================================================================
{
    Reg::setbit(DCRCCON, CRCAPP, tf);
}

//=============================================================================
    void            Dma::crc_type       (CRCTYPE e)
//=============================================================================
{
    Reg::setbit(DCRCCON, CRCTYP, e);
}

//=============================================================================
    void            Dma::crc_ch         (uint8_t v)
//=============================================================================
{
    Reg::clrbit(DCRCCON, CRCCH_CLR<<CRCCH_SHIFT);
    Reg::setbit(DCRCCON, (v bitand CRCCH_CLR)<<CRCCH_SHIFT);
}

//DCRCDATA
//=============================================================================
    void            Dma::crc_seed       (uint32_t v)
//=============================================================================
{
    Reg::val(DCRCDATA, v);
}

//=============================================================================
uint32_t            Dma::crc_data       ()
//=============================================================================
{
    return Reg::val(DCRCDATA);
}

//DCRCXOR
//=============================================================================
    void            Dma::crc_xor        (uint32_t v)
//=============================================================================
{
    Reg::val(DCRCXOR, v);
}

//functions for each channel (class instance)
//DCHXCON
//=============================================================================
    bool            Dma::busy           ()
//=============================================================================
{
    return Reg::anybit(m_dmax_con, CHBUSY);
}

//=============================================================================
    void            Dma::chain          (CHCHAIN e)
//=============================================================================
{
    Reg::setbit(m_dmax_con, CHCHNS, e == TOLOWER);
    Reg::setbit(m_dmax_con, CHCHN, e not_eq CHAINOFF);
}

//=============================================================================
    void            Dma::on             (bool tf)
//=============================================================================
{
    Reg::setbit(m_dmax_con, CHEN, tf);
    while(busy() not_eq tf);
}

//=============================================================================
    void            Dma::evt_always     (bool tf)
//=============================================================================
{
    Reg::setbit(m_dmax_con, CHAED, tf);
}

//=============================================================================
    void            Dma::auto_en        (bool tf)
//=============================================================================
{
    Reg::setbit(m_dmax_con, CHAEN, tf);
}

//=============================================================================
    bool            Dma::evt            ()
//=============================================================================
{
    return Reg::anybit(m_dmax_con, CHEDET);
}

//=============================================================================
    void            Dma::priority       (CHPRI e)
//=============================================================================
{
    Reg::clrbit(m_dmax_con, CHPRI_CLR<<CHPRI_SHIFT);
    Reg::setbit(m_dmax_con, e<<CHPRI_SHIFT);
}

//DCHXECON
//=============================================================================
    void            Dma::irq_abort      (uint8_t v)
//=============================================================================
{
    Reg::val((vu8ptr)m_dmax_con + (DCHXECON * 4) + 2, v);
    Reg::setbit(m_dmax_con + DCHXECON, AIRQEN, v not_eq (uint8_t)IRQOFF);
}

//=============================================================================
    void            Dma::irq_start      (uint8_t v)
//=============================================================================
{
    Reg::val((vu8ptr)m_dmax_con + (DCHXECON * 4) + 1, v);
    Reg::setbit(m_dmax_con + DCHXECON, SIRQEN, v not_eq (uint8_t)IRQOFF);
}

//=============================================================================
    void            Dma::start          ()
//=============================================================================
{
    Reg::setbit(m_dmax_con+DCHXECON, CFORCE);
}

//=============================================================================
    void            Dma::abort          ()
//=============================================================================
{
    Reg::setbit(m_dmax_con+DCHXECON, CABORT);
}

//=============================================================================
    void            Dma::abort_match    (bool tf)
//=============================================================================
{
    Reg::setbit(m_dmax_con+DCHXECON, PATEN, tf);
}

//DCHXINT
//=============================================================================
    void            Dma::irq            (IRQENF e, bool tf)
//=============================================================================
{
    Reg::setbit((vu8ptr)m_dmax_con + (DCHXINT * 4) + 2, e, tf);
}

//=============================================================================
    bool            Dma::flag           (IRQENF e)
//=============================================================================
{
    return Reg::anybit((vu8ptr)m_dmax_con + (DCHXINT * 4) + 2, e);
}

//=============================================================================
    void            Dma::flag_clr       (IRQENF e)
//=============================================================================
{
    Reg::clrbit((vu8ptr)m_dmax_con + (DCHXINT * 4), e);
}

//DCHXSSA
//=============================================================================
    void            Dma::sstart_addr    (uint32_t v)
//=============================================================================
{
    Reg::val(m_dmax_con + DCHXSSA, Reg::k2phys(v));
}

//DCHXDSA
//=============================================================================
    void            Dma::dstart_addr    (uint32_t v)
//=============================================================================
{
    Reg::val(m_dmax_con + DCHXDSA, Reg::k2phys(v));
}

//DCHXSSIZ
//=============================================================================
    void            Dma::ssize          (uint16_t v)
//=============================================================================
{
    Reg::val(m_dmax_con + DCHXSSIZ, v);
}

//DCHXDSIZ
//=============================================================================
    void            Dma::dsize          (uint16_t v)
//=============================================================================
{
    Reg::val(m_dmax_con + DCHXDSIZ, v);
}

//DCHXSPTR
//=============================================================================
    void            Dma::spointer       (uint16_t v)
//=============================================================================
{
    Reg::val(m_dmax_con + DCHXSPTR, v);
}

//DCHXDPTR
//=============================================================================
    void            Dma::dpointer       (uint16_t v)
//=============================================================================
{
    Reg::val(m_dmax_con + DCHXDPTR, v);
}

//DCHXCSIZ
//=============================================================================
    void            Dma::csize          (uint16_t v)
//=============================================================================
{
    Reg::val(m_dmax_con + DCHXCSIZ, v);
}

//DCHXCPTR
//=============================================================================
    uint16_t        Dma::cpointer       ()
//=============================================================================
{
    return Reg::val16(m_dmax_con + DCHXCPTR);
}

//DCHXDAT
//=============================================================================
    void            Dma::pattern        (uint8_t v)
//=============================================================================
{
    Reg::val(m_dmax_con + DCHXDAT, v);
}
