#include "Dma.hpp"

//=============================================================================
                    Dma::Dma            (DMAX e)
//=============================================================================
    : m_dmax_con((volatile uint32_t*)DCH0CON + (e * DCH_SPACING))
{
}

//common static functions
//DMACON
//=============================================================================
    void            Dma::all_on         (bool tf)
//=============================================================================
{
    r.setbit(DMACON, ON, tf);
}

//=============================================================================
    void            Dma::all_suspend    (bool tf)
//=============================================================================
{
    r.setbit(DMACON, SUSPEND, tf);
}

//=============================================================================
    bool            Dma::all_suspend    ()
//=============================================================================
{
    return r.anybit(DMACON, SUSPEND);
}

//=============================================================================
    bool            Dma::any_busy       ()
//=============================================================================
{
    return r.anybit(DMACON, DMABUSY);
}

//DMASTAT
//=============================================================================
    bool            Dma::last_rd        ()
//=============================================================================
{
    return r.anybit(DMASTAT, RDWR);
}

//=============================================================================
    uint8_t         Dma::last_ch        ()
//=============================================================================
{
    return r.val8(DMASTAT) & DMACH_CLR;
}

//DMAADDR
//=============================================================================
    uint32_t        Dma::last_addr      ()
//=============================================================================
{
    return r.val(DMAADDR);
}

//DCRCCON
//=============================================================================
    void            Dma::crc_byto       (CRCBYTO e)
//=============================================================================
{
    r.clrbit(DCRCCON, BYTO_CLR<<BYTO_SHIFT);
    r.setbit(DCRCCON, e<<BYTO_SHIFT);
    r.setbit(DCRCCON, WBO, (bool)e);
}

//=============================================================================
    void            Dma::crc_bito       (CRCBITO e)
//=============================================================================
{
    r.setbit(DCRCCON, BITO, e);
}

//=============================================================================
    void            Dma::crc_polyn      (uint8_t v)
//=============================================================================
{
    r.clrbit(DCRCCON, PLEN_CLR<<PLEN_SHIFT);
    r.setbit(DCRCCON, (v & PLEN_CLR)<<PLEN_SHIFT);
}

//=============================================================================
    void            Dma::crc_on         (bool tf)
//=============================================================================
{
    r.setbit(DCRCCON, CRCEN, tf);
}

//=============================================================================
    void            Dma::crc_append     (bool tf)
//=============================================================================
{
    r.setbit(DCRCCON, CRCAPP, tf);
}

//=============================================================================
    void            Dma::crc_type       (CRCTYPE e)
//=============================================================================
{
    r.setbit(DCRCCON, CRCTYP, e);
}

//=============================================================================
    void            Dma::crc_ch         (uint8_t v)
//=============================================================================
{
    r.clrbit(DCRCCON, CRCCH_CLR<<CRCCH_SHIFT);
    r.setbit(DCRCCON, (v & CRCCH_CLR)<<CRCCH_SHIFT);
}

//DCRCDATA
//=============================================================================
    void            Dma::crc_seed       (uint32_t v)
//=============================================================================
{
    r.val(DCRCDATA, v);
}

//=============================================================================
uint32_t            Dma::crc_data       ()
//=============================================================================
{
    return r.val(DCRCDATA);
}

//DCRCXOR
//=============================================================================
    void            Dma::crc_xor        (uint32_t v)
//=============================================================================
{
    r.val(DCRCXOR, v);
}

//functions for each channel (class instance)
//DCHXCON
//=============================================================================
    bool            Dma::busy           ()
//=============================================================================
{
    return r.anybit(m_dmax_con, CHBUSY);
}

//=============================================================================
    void            Dma::chain          (CHCHAIN e)
//=============================================================================
{
    r.setbit(m_dmax_con, CHCHNS, e == TOLOWER);
    r.setbit(m_dmax_con, CHCHN, e not_eq CHAINOFF);
}

//=============================================================================
    void            Dma::on             (bool tf)
//=============================================================================
{
    r.setbit(m_dmax_con, CHEN, tf);
    while(busy() not_eq tf);
}

//=============================================================================
    void            Dma::evt_always     (bool tf)
//=============================================================================
{
    r.setbit(m_dmax_con, CHAED, tf);
}

//=============================================================================
    void            Dma::auto_en        (bool tf)
//=============================================================================
{
    r.setbit(m_dmax_con, CHAEN, tf);
}

//=============================================================================
    bool            Dma::evt            ()
//=============================================================================
{
    return r.anybit(m_dmax_con, CHEDET);
}

//=============================================================================
    void            Dma::priority       (CHPRI e)
//=============================================================================
{
    r.clrbit(m_dmax_con, CHPRI_CLR<<CHPRI_SHIFT);
    r.setbit(m_dmax_con, e<<CHPRI_SHIFT);
}

//DCHXECON
//=============================================================================
    void            Dma::irq_abort      (uint8_t v)
//=============================================================================
{
    r.val((vbyte_ptr)m_dmax_con + (DCHXECON * 4) + 2, v);
    r.setbit(m_dmax_con + DCHXECON, AIRQEN, v not_eq (uint8_t)IRQOFF);
}

//=============================================================================
    void            Dma::irq_start      (uint8_t v)
//=============================================================================
{
    r.val((vbyte_ptr)m_dmax_con + (DCHXECON * 4) + 1, v);
    r.setbit(m_dmax_con + DCHXECON, SIRQEN, v not_eq (uint8_t)IRQOFF);
}

//=============================================================================
    void            Dma::start          ()
//=============================================================================
{
    r.setbit(m_dmax_con+DCHXECON, CFORCE);
}

//=============================================================================
    void            Dma::abort          ()
//=============================================================================
{
    r.setbit(m_dmax_con+DCHXECON, CABORT);
}

//=============================================================================
    void            Dma::abort_match    (bool tf)
//=============================================================================
{
    r.setbit(m_dmax_con+DCHXECON, PATEN, tf);
}

//DCHXINT
//=============================================================================
    void            Dma::irq            (IRQENF e, bool tf)
//=============================================================================
{
    r.setbit((vbyte_ptr)m_dmax_con + (DCHXINT * 4) + 2, e, tf);
}

//=============================================================================
    bool            Dma::flag           (IRQENF e)
//=============================================================================
{
    return r.anybit((vbyte_ptr)m_dmax_con + (DCHXINT * 4) + 2, e);
}

//=============================================================================
    void            Dma::flag_clr       (IRQENF e)
//=============================================================================
{
    r.clrbit((vbyte_ptr)m_dmax_con + (DCHXINT * 4), e);
}

//DCHXSSA
//=============================================================================
    void            Dma::sstart_addr    (uint32_t v)
//=============================================================================
{
    r.val(m_dmax_con + DCHXSSA, r.k2phys(v));
}

//DCHXDSA
//=============================================================================
    void            Dma::dstart_addr    (uint32_t v)
//=============================================================================
{
    r.val(m_dmax_con + DCHXDSA, r.k2phys(v));
}

//DCHXSSIZ
//=============================================================================
    void            Dma::ssize          (uint16_t v)
//=============================================================================
{
    r.val(m_dmax_con + DCHXSSIZ, v);
}

//DCHXDSIZ
//=============================================================================
    void            Dma::dsize          (uint16_t v)
//=============================================================================
{
    r.val(m_dmax_con + DCHXDSIZ, v);
}

//DCHXSPTR
//=============================================================================
    void            Dma::spointer       (uint16_t v)
//=============================================================================
{
    r.val(m_dmax_con + DCHXSPTR, v);
}

//DCHXDPTR
//=============================================================================
    void            Dma::dpointer       (uint16_t v)
//=============================================================================
{
    r.val(m_dmax_con + DCHXDPTR, v);
}

//DCHXCSIZ
//=============================================================================
    void            Dma::csize          (uint16_t v)
//=============================================================================
{
    r.val(m_dmax_con + DCHXCSIZ, v);
}

//DCHXCPTR
//=============================================================================
    uint16_t        Dma::cpointer       ()
//=============================================================================
{
    return r.val16(m_dmax_con + DCHXCPTR);
}

//DCHXDAT
//=============================================================================
    void            Dma::pattern        (uint8_t v)
//=============================================================================
{
    r.val(m_dmax_con + DCHXDAT, v);
}
