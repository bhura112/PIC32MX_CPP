#include "Spi.hpp"
#include "Osc.hpp"
#include "Reg.hpp"

enum :uint32_t {
    SPIX_SPACING = 0x40, //spacing in words
    SPI1CON = 0xBF808100,
        FRMEN = 31,
        FRMSYNC = 30,
        FRMPOL = 29,
        MSSEN = 28,
        FRMSYPW = 27,
        FRMCNT_SHIFT = 24, FRMCNT_MASK = 7,
        MCLKSEL = 23,
        SPIFE = 17,
        ENHBUF = 16,
        ON = 15,
        MODE_SHIFT = 10, MODE_MASK = 3,
        SMP = 9,
        CKE = 8,
        SSEN = 7,
        CKP = 6,
        MSTEN = 5,
        STXISEL_SHIFT = 2, STXISEL_MASK = 3,
        SRXISEL_SHIFT = 0, SRXISEL_MASK = 3,
    SPIXSTAT = 4, //offset from SPIXCON in words
        FRMERR = 12,
        SPIBUSY = 11,
        SPITUR = 8,
        SRMT = 7,
        SPIROV = 6,
        SPIRBE = 5,
        SPITBE = 3,
        SPITBF = 1,
        SPIRBF = 0,
    SPIXBUF = 8, //offset from SPIXCON in words
    SPIXBRG = 12, //offset from SPIXCON in words
    SPIXCON2 = 16, //offset from SPIXCON in words
        SPISGNEXT = 15,
        FRMERREN = 12,
        SPIROVEN = 11,
        SPITUREN = 10,
        IGNROV = 9,
        IGNTUR = 8,
        AUDEN = 7,
        AUDOMONO = 3
};

using vu8ptr = volatile uint8_t*;            //access stat as bytes
using vu32ptr = volatile uint32_t*;

//Spi

//=============================================================================
                Spi::Spi        (SPIX e)
//=============================================================================
    : m_spix_con((vu32ptr)SPI1CON + (e * SPIX_SPACING)),
      m_spixbuf(*((vu32ptr)SPI1CON + (e * SPIX_SPACING) + SPIXBUF)),
      m_spix_freq(0)
{
}

//spixcon
//=============================================================================
    void        Spi::frame              (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<FRMEN, tf);
}

//=============================================================================
    void        Spi::frame_dir          (FRMDIR e)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<FRMSYNC, e);
}

//=============================================================================
    void        Spi::frame_pol          (FRMHL e)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<FRMPOL, e);
}

//=============================================================================
    void        Spi::slave_sel          (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<MSSEN, tf);
}

//=============================================================================
    void        Spi::frame_pwidth       (FRMPW e)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<FRMSYPW, e);
}

//=============================================================================
    void        Spi::frame_count        (FRMCNT e)
//=============================================================================
{
    Reg::clrbit(m_spix_con, FRMCNT_MASK<<FRMCNT_SHIFT);
    Reg::setbit(m_spix_con, e<<FRMCNT_SHIFT);
}

//=============================================================================
    void        Spi::clk_sel            (CLKSEL e)
//=============================================================================
{
    bool ison = Reg::anybit(m_spix_con, ON);
    on(false);
    Reg::setbit(m_spix_con, 1<<MCLKSEL, e);
    freq(); //recaluclate
    on(ison);
}

//=============================================================================
    auto        Spi::clk_sel            () -> CLKSEL
//=============================================================================
{
    return (CLKSEL)Reg::anybit(m_spix_con, 1<<MCLKSEL);
}

//=============================================================================
    void        Spi::frame_edge         (FRMEDGE e)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<SPIFE, e);
}

//=============================================================================
    void        Spi::enhanced           (bool tf)
//=============================================================================
{
    bool ison = Reg::anybit(m_spix_con, 1<<ON);
    on(false);
    Reg::setbit(m_spix_con, 1<<ENHBUF, tf);
    on(ison);
}

//=============================================================================
    void        Spi::on                 (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<ON, tf);
}

//=============================================================================
    void        Spi::mode               (MODE e)
//=============================================================================
{
    Reg::clrbit(m_spix_con, MODE_MASK<<MODE_SHIFT);
    Reg::setbit(m_spix_con, e<<MODE_SHIFT);
}

//=============================================================================
    void        Spi::phase              (PHASE e)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<SMP, e);
}

//=============================================================================
    void        Spi::clk_edge           (CLKEDGE e)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<CKE, e);
}

//=============================================================================
    void        Spi::ss                 (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<SSEN, tf);
}

//=============================================================================
    void        Spi::clk_pol            (CLKPOL e)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<CKP, e);
}

//=============================================================================
    void        Spi::master             (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con, 1<<MSTEN, tf);
}

//=============================================================================
    void        Spi::tx_irq             (TXIRQ e)
//=============================================================================
{
    Reg::clrbit(m_spix_con, STXISEL_MASK<<STXISEL_SHIFT);
    Reg::setbit(m_spix_con, e<<STXISEL_SHIFT);
}

//=============================================================================
    void        Spi::rx_irq             (RXIRQ e)
//=============================================================================
{
    Reg::clrbit(m_spix_con, SRXISEL_MASK<<SRXISEL_SHIFT);
    Reg::setbit(m_spix_con, e<<SRXISEL_SHIFT);
}

//spixstat
//=============================================================================
    uint8_t     Spi::stat_rxcount       ()
//=============================================================================
{
    return Reg::val8((vu8ptr)m_spix_con + (SPIXSTAT * 4) + 3);
}

//=============================================================================
    uint8_t     Spi::stat_txcount       ()
//=============================================================================
{
    return Reg::val8((vu8ptr)m_spix_con + (SPIXSTAT * 4) + 2);
}

//=============================================================================
    bool        Spi::stat_ferr          ()
//=============================================================================
{
    return Reg::anybit(m_spix_con + SPIXSTAT, 1<<FRMERR);
}

//=============================================================================
    void        Spi::stat_ferrclr       ()
//=============================================================================
{
    Reg::clrbit(m_spix_con + SPIXSTAT, 1<<FRMERR);
}

//=============================================================================
    bool        Spi::stat_busy          ()
//=============================================================================
{
    return Reg::anybit(m_spix_con + SPIXSTAT, 1<<SPIBUSY);
}

//=============================================================================
    bool        Spi::stat_txurun        ()
//=============================================================================
{
    return Reg::anybit(m_spix_con + SPIXSTAT, 1<<SPITUR);
}

//=============================================================================
    bool        Spi::stat_sremty        ()
//=============================================================================
{
    return Reg::anybit(m_spix_con + SPIXSTAT, 1<<SRMT);
}

//=============================================================================
    bool        Spi::stat_oerr          ()
//=============================================================================
{
    return Reg::anybit(m_spix_con + SPIXSTAT, 1<<SPIROV);
}

//=============================================================================
    void        Spi::stat_oerrclr       ()
//=============================================================================
{
    Reg::clrbit(m_spix_con + SPIXSTAT, 1<<SPIROV);
}

//=============================================================================
    bool        Spi::stat_rxemty        ()
//=============================================================================
{
    return Reg::anybit(m_spix_con + SPIXSTAT, 1<<SPIRBE);
}

//=============================================================================
    bool        Spi::stat_txemty        ()
//=============================================================================
{
    return Reg::anybit(m_spix_con + SPIXSTAT, 1<<SPITBE);
}

//=============================================================================
    bool        Spi::stat_txfull        ()
//=============================================================================
{
    return Reg::anybit(m_spix_con + SPIXSTAT, 1<<SPITBF);
}

//=============================================================================
    bool        Spi::stat_rxfull        ()
//=============================================================================
{
     return Reg::anybit(m_spix_con + SPIXSTAT, 1<<SPIRBF);
}

//spixbrg
//=============================================================================
    void        Spi::baud               (uint16_t v)
//=============================================================================
{
    Reg::val(m_spix_con + SPIXBRG, v);
}

//set frequency
//=============================================================================
    void        Spi::freq               (uint32_t v)
//=============================================================================
{
    uint32_t clk;
    if(clk_sel() == REFO1) clk = Osc::refo_freq();
    else clk = Osc::sysclk();
    uint16_t brg = (2 * v / clk) - 1;
    brg and_eq 0x1ff;
    baud(brg);
    freq();
}

//get actual frequency
//called by clk_sel(), freq(uint32_t)
//=============================================================================
    uint32_t    Spi::freq               ()
//=============================================================================
{
    uint32_t clk;
    if(clk_sel() == REFO1) clk = Osc::refo_freq();
    else clk = Osc::sysclk();
    m_spix_freq = clk / (2 * Reg::val16(m_spix_con + SPIXBRG) + 1);
    return m_spix_freq;
}

//spixcon2
//=============================================================================
    void        Spi::sign_ext           (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con + SPIXCON2, 1<<SPISGNEXT, tf);
}

//=============================================================================
    void        Spi::irq_frmerr         (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con + SPIXCON2, 1<<FRMERREN, tf);
}

//=============================================================================
    void        Spi::irq_oflow          (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con + SPIXCON2, 1<<SPIROVEN, tf);
}

//=============================================================================
    void        Spi::irq_urun           (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con + SPIXCON2, 1<<SPITUREN, tf);
}

//=============================================================================
    void        Spi::ign_oflow          (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con + SPIXCON2, 1<<IGNROV, tf);
}

//=============================================================================
    void        Spi::ign_urun           (bool tf)
//=============================================================================
{
    Reg::setbit(m_spix_con + SPIXCON2, 1<<IGNTUR, tf);
}

//=============================================================================
    void        Spi::audio              (bool tf)
//=============================================================================
{
    bool ison = Reg::anybit(m_spix_con, 1<<ON);
    on(false);
    Reg::setbit(m_spix_con + SPIXCON2, 1<<AUDEN, tf);
    on(ison);
}

//=============================================================================
    void        Spi::mono               (bool tf)
//=============================================================================
{
    bool ison = Reg::anybit(m_spix_con, 1<<ON);
    on(false);
    Reg::setbit(m_spix_con + SPIXCON2, 1<<AUDOMONO, tf);
    on(ison);
}

//=============================================================================
    void        Spi::audio_mode         (AUDMOD e)
//=============================================================================
{
    bool ison = Reg::anybit(m_spix_con, 1<<ON);
    on(false);
    Reg::clrbit(m_spix_con + SPIXCON2, PCMDSP);
    Reg::setbit(m_spix_con + SPIXCON2, e);
    on(ison);
}

//spixbuf
//=============================================================================
    void            Spi::write      (uint32_t v)
//=============================================================================
{
    m_spixbuf = v; //m_spibuf&
}

//=============================================================================
    uint32_t        Spi::read       ()
//=============================================================================
{
    return m_spixbuf; //m_spibuf&
}
