#include "Timer23.hpp"
#include "Reg.hpp"

enum {
    ON = 15,
    SIDL = 13,
    TGATE = 7,
    TCKPS_SHIFT = 4, TCKPS_CLR = 7,
    T32 = 3,
    TCS = 1
};

enum { T1CON = 0xBF808040, TMR23_SPACING = 0x10 }; //spacing in words

using vu32ptr = volatile uint32_t*;


//Timer23
//=============================================================================
                Timer23::Timer23        (TMR23 e)
//=============================================================================
    : m_txcon( (vu32ptr)T1CON + (e * TMR23_SPACING) ),
      m_tmrx( *((vu32ptr)T1CON + (e * TMR23_SPACING) + 4) ),
      m_prx( *((vu32ptr)T1CON + (e * TMR23_SPACING) + 8) )
{
}

//=============================================================================
    void        Timer23::count          (uint32_t n) const
//=============================================================================
{
    m_tmrx = n;
    if(Reg::anybit(m_txcon, 1<<T32)){
        *((vu32ptr)m_tmrx + TMR23_SPACING) = n>>16;
    }
}

//=============================================================================
    uint32_t    Timer23::count          () const
//=============================================================================
{
    uint32_t ret = 0;
    if(Reg::anybit(m_txcon, 1<<T32)){
        ret = *((vu32ptr)m_tmrx + TMR23_SPACING)<<16;
    }
    return ret | m_tmrx;
}

//=============================================================================
    void        Timer23::period         (uint32_t n) const
//=============================================================================
{
    m_prx = n;
    if(Reg::anybit(m_txcon, 1<<T32)){
        *((vu32ptr)m_prx + TMR23_SPACING) = n>>16;
    }
}

//=============================================================================
    uint32_t    Timer23::period         () const
//=============================================================================
{
    uint32_t ret = 0;
    if(Reg::anybit(m_txcon, 1<<T32)){
        ret = *((vu32ptr)m_prx + TMR23_SPACING)<<16;
    }
    return ret | m_prx;
}

//=============================================================================
    void        Timer23::on             (bool tf) const
//=============================================================================
{
    Reg::setbit(m_txcon, 1<<ON, tf);
}

//=============================================================================
    void        Timer23::stop_idle      (bool tf) const
//=============================================================================
{
    Reg::setbit(m_txcon, 1<<SIDL, tf);
}

//=============================================================================
    void        Timer23::gate           (bool tf) const
//=============================================================================
{
    Reg::setbit(m_txcon, 1<<TGATE, tf);
}

//=============================================================================
    void        Timer23::prescale       (PRESCALE e) const
//=============================================================================
{
    Reg::clrbit(m_txcon, TCKPS_CLR<<TCKPS_SHIFT);
    Reg::setbit(m_txcon, e<<TCKPS_SHIFT);
}

//=============================================================================
    void        Timer23::mode32         (bool tf) const
//=============================================================================
{
    Reg::setbit(m_txcon, 1<<T32, tf);
    //if turned on, bit will 'stick'
    //so must be T2, make sure T3 SIDL is off
    if(tf and Reg::anybit(m_txcon, 1<<T32)){
       Reg::clrbit(m_txcon + TMR23_SPACING, SIDL);
    }
}

//=============================================================================
    void        Timer23::clk_src        (CLK e) const
//=============================================================================
{
    Reg::setbit(m_txcon, 1<<TCS, e);
}
