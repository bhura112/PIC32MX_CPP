#include "Clc.hpp"

//=============================================================================
                    Clc::Clc        (CLCX e)
//=============================================================================
    : m_clcx_con((volatile uint32_t*)CLC1CON + (e * CLCXCON_SPACING))
{
}

//=============================================================================
    void            Clc::gate_inv       (GXPOL e, bool tf)
//=============================================================================
{
    r.setbit(m_clcx_con, e, tf);
}

//=============================================================================
    void            Clc::on             (bool tf)
//=============================================================================
{
    r.setbit(m_clcx_con, ON, tf);
}

//=============================================================================
    void            Clc::stop_idle      (bool tf)
//=============================================================================
{
    r.setbit(m_clcx_con, SIDL, tf);
}

//=============================================================================
    void            Clc::intp           (bool tf)
//=============================================================================
{
    r.setbit(m_clcx_con, INTP, tf);
}

//=============================================================================
    void            Clc::intn           (bool tf)
//=============================================================================
{
    r.setbit(m_clcx_con, INTN, tf);
}

//=============================================================================
    void            Clc::out            (bool tf)
//=============================================================================
{
    r.setbit(m_clcx_con, LCOE, tf);
}

//=============================================================================
    bool            Clc::out            ()
//=============================================================================
{
    return r.anybit(m_clcx_con, LCOUT);
}

//=============================================================================
    void            Clc::out_inv        (bool tf)
//=============================================================================
{
    r.setbit(m_clcx_con, LCPOL, tf);
}

//=============================================================================
    void            Clc::mode           (MODE e)
//=============================================================================
{
    r.clrbit(m_clcx_con, LSR);
    r.setbit(m_clcx_con, e);
}

//input select, n = 1-4, v = 0-7 (invalid args masked to good vals)
//=============================================================================
    void            Clc::in_sel         (uint8_t n, uint8_t v)
//=============================================================================
{
    n -= 1; n and_eq 3; n <<= 2; v and_eq 7;
    r.clrbit(m_clcx_con + CLCXSEL, 7<<n);
    r.setbit(m_clcx_con + CLCXSEL, v<<n);
}

//or all in in shot with precomputed value
//=============================================================================
    void            Clc::in_sel         (uint32_t v)
//=============================================================================
{
    r.val(m_clcx_con + CLCXSEL, v);
}

//gate select, n = 1-4 (invalid gate masked to good gate)
//=============================================================================
    void            Clc::gate_sel       (uint8_t n, uint8_t v)
//=============================================================================
{
    n -= 1; n and_eq 3; n <<= 3;
    r.clrbit(m_clcx_con + CLCXGLS, 15<<n);
    r.setbit(m_clcx_con + CLCXGLS, v<<n);
}

//or all in in shot with precomputed value
//=============================================================================
    void            Clc::gate_sel       (uint32_t v)
//=============================================================================
{
    r.val(m_clcx_con+CLCXGLS, v);
}
