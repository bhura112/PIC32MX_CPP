#include "Adc.hpp"
#include "Reg.hpp"

enum {
    ADC1BUF0 = 0xBF802100, ADC1BUF_SPACING = 0x10, ADC1BUF_LAST = 21,
    ADC1CON1 = 0xBF802260,
        ON = 1<<15,
        SIDL = 1<<13,
        FORM_SHIFT = 8, FORM_CLR = 7,
        SSRC_SHIFT = 4, SSRC_CLR = 15,
        MODE12 = 1<<3,
        ASAM = 1<<2,
        SAMP = 1<<1,
        DONE = 1<<0,
    ADC1CON2 = 0xBF802270,
        VCFG_SHIFT = 13, VCFG_CLR = 7,
        OFFCAL = 1<<12,
        BUFREGEN = 1<<11,
        CSCNA = 1<<10,
        BUFS = 1<<7,
        SMPI_SHIFT = 2, SMPI_CLR = 7,
        BUFM = 1<<1,
    ADC1CON3 = 0xBF802280,
        ADRC = 1<<15,
        EXTSAM = 1<<14,
        SAMC_SHIFT = 8, SAMC_CLR = 31,
    ADC1CHS = 0xBF802290,
    ADC1CSS = 0xBF8022A0,
    ADC1CON5 = 0xBF8022C0,
        ASEN = 1<<15,
        LPEN = 1<<14,
        BGREQ = 1<<12,
        ASINT_SHIFT = 8, ASINT_CLR = 3,
        WM_SHIFT = 2, WM_CLR = 3,
        CM_SHIFT = 0, CM_CLR = 3,
    ADC1CHIT = 0xBF8022D0
};

//ADC1BUFn
//=============================================================================
    uint16_t        Adc::read           (uint8_t n)
//=============================================================================
{
    if(n > ADC1BUF_LAST) n = ADC1BUF_LAST;
    return Reg::val16(ADC1BUF0 + (n * ADC1BUF_SPACING));
}

//=============================================================================
    uint16_t        Adc::read           ()
//=============================================================================
{
    return Reg::val16(ADC1BUF0);
}

//ADC1CON1
//=============================================================================
    void            Adc::on             (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON1, ON, tf);
}

//=============================================================================
    void            Adc::stop_idle      (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON1, SIDL, tf);
}

//=============================================================================
    void            Adc::format         (FORM e)
//=============================================================================
{
    Reg::clrbit(ADC1CON1, FORM_CLR<<FORM_SHIFT);
    Reg::setbit(ADC1CON1, e<<FORM_SHIFT);
}

//=============================================================================
    void            Adc::trig_sel       (SSRC e)
//=============================================================================
{
    Reg::clrbit(ADC1CON1, SSRC_CLR<<SSRC_SHIFT);
    Reg::setbit(ADC1CON1, e<<SSRC_SHIFT);
}

//=============================================================================
    void            Adc::mode_12bit     (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON1, MODE12, tf);
}

//=============================================================================
    void            Adc::samp_auto      (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON1, ASAM, tf);
}

//=============================================================================
    void            Adc::samp           (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON1, SAMP, tf);
}

//=============================================================================
    bool            Adc::samp           ()
//=============================================================================
{
    return Reg::anybit(ADC1CON1, SAMP);
}

//=============================================================================
    bool            Adc::done           ()
//=============================================================================
{
    return Reg::anybit(ADC1CON1, DONE);
}

//ADC1CON2
//=============================================================================
    void            Adc::vref_cfg       (VCFG e)
//=============================================================================
{
    Reg::clrbit(ADC1CON2, VCFG_CLR<<VCFG_SHIFT);
    Reg::setbit(ADC1CON2, e<<VCFG_SHIFT);
}

//=============================================================================
    void            Adc::offset_cal     (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON2, OFFCAL, tf);
}

//=============================================================================
    void            Adc::buf_reg        (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON2, BUFREGEN, tf);
}

//=============================================================================
    void            Adc::scan           (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON2, CSCNA, tf);
}

//=============================================================================
    bool            Adc::buf2nd_busy    ()
//=============================================================================
{
    return Reg::anybit(ADC1CON2, BUFS);
}

//=============================================================================
    void            Adc::samp_nirq      (uint8_t n)
//=============================================================================
{
    n -= 1; n and_eq 15; //n = 1-16 ->0-15
    Reg::clrbit(ADC1CON2, SMPI_CLR<<SMPI_SHIFT);
    Reg::setbit(ADC1CON2, n<<SMPI_SHIFT);
}

//=============================================================================
    void            Adc::buf_split      (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON2, BUFM, tf);
}

//ADC1CON3
//=============================================================================
    void            Adc::clk_src        (CLK e)
//=============================================================================
{
    Reg::setbit(ADC1CON3, ADRC, e);
}

//=============================================================================
    void            Adc::samp_extend    (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON3, EXTSAM, tf);
}

//=============================================================================
    void            Adc::samp_time      (uint8_t v)
//=============================================================================
{
    v and_eq 31; v = v == 0 ? 1 : v; //0 not allowed (1-31)
    Reg::clrbit(ADC1CON3, SAMC_CLR<<SAMC_SHIFT);
    Reg::setbit(ADC1CON3, v<<SAMC_SHIFT);
}

//default value is for 24MHz, 4 will meet 280ns Tad for any clock
//=============================================================================
    void            Adc::conv_time      (uint8_t v)
//=============================================================================
{
    Reg::val(ADC1CON3, v);
}

//ADC1CON5
//=============================================================================
    void            Adc::scan_auto      (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON5, ASEN, tf);
}

//=============================================================================
    void            Adc::low_power      (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON5, LPEN, tf);
}

//=============================================================================
    void            Adc::bandgap        (bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CON5, BGREQ, tf);
}

//=============================================================================
    void            Adc::scan_autoirq   (ASINT e)
//=============================================================================
{
    Reg::clrbit(ADC1CON5, ASINT_CLR<<ASINT_SHIFT);
    Reg::setbit(ADC1CON5, e<<ASINT_SHIFT);
}

//=============================================================================
    void            Adc::write_mode     (WM e)
//=============================================================================
{
    Reg::clrbit(ADC1CON5, WM_CLR<<WM_SHIFT);
    Reg::setbit(ADC1CON5, e<<WM_SHIFT);
}

//=============================================================================
    void            Adc::compare_mode   (CM e)
//=============================================================================
{
    Reg::clrbit(ADC1CON5, CM_CLR<<CM_SHIFT);
    Reg::setbit(ADC1CON5, e<<CM_SHIFT);
}

//ADC1CHS
//=============================================================================
    void            Adc::ch_sel         (CH0SA e)
//=============================================================================
{
    Reg::val(ADC1CHS, e);
}

//=============================================================================
    void            Adc::ch_sel         (uint8_t v)
//=============================================================================
{
    Reg::val(ADC1CHS, v);
}

//ADC1SS
//=============================================================================
    void            Adc::ch_scan        (CH0SA e, bool tf)
//=============================================================================
{
    Reg::setbit(ADC1CSS, e, tf);
}

//=============================================================================
    void            Adc::ch_scan        (CH0SA* e)
//=============================================================================
{
    Reg::val(ADC1CSS, 0); //clr all
    for(; *e not_eq END; e++) Reg::setbit(ADC1CSS, 1<<*e); //set list
}

//=============================================================================
    void            Adc::ch_scan        (uint32_t v)
//=============================================================================
{
    Reg::val(ADC1CSS, v);
}

//ADC1CHIT
//non AN values will return 0 (like VDD)
//=============================================================================
    bool            Adc::ch_hit         (CH0SA e)
//=============================================================================
{
    return Reg::anybit(ADC1CHIT, 1<<e);
}

//=============================================================================
    uint32_t        Adc::ch_hit         ()
//=============================================================================
{
    return Reg::val(ADC1CHIT);
}
