#include "Ccp.hpp"
#include "Osc.hpp"
#include "Reg.hpp"

enum : uint32_t {
    CCP1CON1 = 0xBF800100, CCPX_SPACING = 0x40,  //spacing in words
        OPSSRC = 1u<<31,
        RTRGEN = 1<<30,
        OPS_SHIFT = 24, OPS_CLR = 15,
        TRIGEN = 1<<23,
        ONESHOT = 1<<22,
        ALTSYNC = 1<<21,
        SYNC_SHIFT = 16, SYNC_CLR = 31,
        ON = 1<<15,
        SIDL = 1<<13,
        CCPSLP = 1<<12,
        TMRSYNC = 1<<11,
        CLKSEL_SHIFT = 8, CLKSEL_CLR = 7,
        TMRPS_SHIFT = 6, TMRPS_CLR = 3,
        T32 = 1<<5, //combined into MODE
        CCSEL = 1<<4, //combined into MODE
        MOD_SHIFT = 0, MOD_CLR = 15,
        MODE_SHIFT = 0, MODE_CLR = 63,
    CCPXCON2 = 4, //offset in words from ccp1con1
        OENSYNC = 1u<<31,
        OCFEN = 1<<29,
        OCEEN = 1<<28,
        OCDEN = 1<<27,
        OCCEN = 1<<26,
        OCBEN = 1<<25,
        OCAEN = 1<<24,
        OCPINS_SHIFT = 24, OCPINS_CLR = 63,
        ICGSM_SHIFT = 22, ICGSM_CLR = 3,
        AUXOUT_SHIFT = 19, AUXOUT_CLR = 3,
        ICS_SHIFT = 16, ICS_CLR = 7,
        PWMRSEN = 1<<15,
        ASDGM = 1<<14,
        SSDG = 1<<12,
        ASDG_SHIFT = 0, ASDG_CLR = 255,
    CCPXCON3 = 8,
        OETRIG = 1u<<31,
        OSCNT_SHIFT = 28, OSCNT_CLR = 7,
        OUTM_SHIFT = 24, OUTM_CLR = 7,
        POLACE = 1<<21,
        POLBDF = 1<<20,
        PSSACE_SHIFT = 18, PSSACE_CLR = 3,
        PSSBDF_SHIFT = 16, PSSBDF_CLR = 3,
        DT_SHIFT = 0, DT_CLR = 63,
    CCPXSTAT = 12,
        PRLWIP = 1<<20,
        TMRHWIP = 1<<19,
        TMRLWIP = 1<<18,
        RBWIP = 1<<17,
        RAWIP = 1<<16,
        ICGARM = 1<<10,
        CCPTRIG = 1<<7,
        TRSET = 1<<6,
        TRCLR = 1<<5,
        ASEVT = 1<<4,
        SCEVT = 1<<3,
        ICDIS = 1<<2,
        ICOV = 1<<1,
        ICBNE = 1<<0,
    CCPXTMR = 16,
    CCPXPR = 20,
    CCPXRA = 24,
    CCPXRB = 28,
    CCPXBUF = 32,
};

using vu8ptr = volatile uint8_t*;
using vu32ptr = volatile uint32_t*;

//MCCP/SCCP

//=============================================================================
                Ccp::Ccp        (CCPX e)
//=============================================================================
    : m_ccpx_con((vu32ptr)CCP1CON1 + (e * CCPX_SPACING))
{
}

//ccpxcon1
//=============================================================================
    void        Ccp::outscale_src       (OPOSTSRC e)
//=============================================================================
{
    Reg::setbit(m_ccpx_con, OPSSRC, e);
}

//=============================================================================
    void        Ccp::retrigger          (bool tf)
//=============================================================================
{
    Reg::setbit(m_ccpx_con, RTRGEN, tf);
}

//=============================================================================
    void        Ccp::outscale           (uint8_t v)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con, OPS_CLR<<OPS_SHIFT);
    Reg::setbit(m_ccpx_con, (v bitand OPS_CLR)<<OPS_SHIFT);
}

//=============================================================================
    void        Ccp::trig_mode          ()
//=============================================================================
{
    Reg::setbit(m_ccpx_con, TRIGEN);
}

//=============================================================================
    void        Ccp::sync_mode          ()
//=============================================================================
{
    Reg::clrbit(m_ccpx_con, TRIGEN);
}

//=============================================================================
    void        Ccp::oneshot            (bool tf)
//=============================================================================
{
    Reg::setbit(m_ccpx_con, ONESHOT, tf);
}

//=============================================================================
    void        Ccp::sync_altout        (bool tf)
//=============================================================================
{
    Reg::setbit(m_ccpx_con, ALTSYNC, tf);
}

//=============================================================================
    void        Ccp::sync_src           (SYNC e)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con, SYNC_CLR<<SYNC_SHIFT);
    Reg::setbit(m_ccpx_con, e<<SYNC_SHIFT);
}

//=============================================================================
    void        Ccp::on                 (bool tf)
//=============================================================================
{
    Reg::setbit(m_ccpx_con, ON, tf);
}

//=============================================================================
    void        Ccp::stop_idle          (bool tf)
//=============================================================================
{
    Reg::setbit(m_ccpx_con, SIDL, not tf);
}

//=============================================================================
    void        Ccp::stop_sleep         (bool tf)
//=============================================================================
{
    Reg::setbit(m_ccpx_con, CCPSLP, not tf);
}

//=============================================================================
    void        Ccp::sync_tmr           (bool tf)
//=============================================================================
{
    Reg::setbit(m_ccpx_con, TMRSYNC, tf);
}

//=============================================================================
    void        Ccp::clk_src            (CLKSEL e)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con, CLKSEL_CLR<<CLKSEL_SHIFT);
    Reg::setbit(m_ccpx_con, e<<CLKSEL_SHIFT);
    if(e == SOSC) Osc::sosc(true);
}

//=============================================================================
    void        Ccp::tmr_prescale       (TMRPS e)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con, TMRPS_CLR<<TMRPS_SHIFT);
    Reg::setbit(m_ccpx_con, e<<TMRPS_SHIFT);
}

//=============================================================================
    void        Ccp::mode               (MODE e)
//=============================================================================
{
    bool ison = Reg::anybit(m_ccpx_con, ON);
    on(false);
    Reg::clrbit(m_ccpx_con, MODE_CLR<<MODE_SHIFT);
    Reg::setbit(m_ccpx_con, e<<MODE_SHIFT);
    if(ison) on(true);
}

//ccpxcon2
//=============================================================================
    void        Ccp::out_sync           (bool tf)
//=============================================================================
{
   Reg::setbit(m_ccpx_con + CCPXCON2, OENSYNC, tf);
}

//=============================================================================
    void        Ccp::out_pins           (OUTPINS e)
//=============================================================================
{
   Reg::clrbit(m_ccpx_con + CCPXCON2, OCPINS_CLR<<OCPINS_SHIFT);
   Reg::setbit(m_ccpx_con + CCPXCON2, e<<OCPINS_SHIFT);
}

//=============================================================================
    void        Ccp::gate_mode          (ICGSM e)
//=============================================================================
{
   Reg::clrbit(m_ccpx_con + CCPXCON2, ICGSM_CLR<<ICGSM_SHIFT);
   Reg::setbit(m_ccpx_con + CCPXCON2, e<<ICGSM_SHIFT);
}

//=============================================================================
    void        Ccp::out_aux            (AUXOUT e)
//=============================================================================
{
   Reg::clrbit(m_ccpx_con + CCPXCON2, AUXOUT_CLR<<AUXOUT_SHIFT);
   Reg::setbit(m_ccpx_con + CCPXCON2, e<<AUXOUT_SHIFT);
}

//=============================================================================
    void        Ccp::cap_src            (ICS e)
//=============================================================================
{
   Reg::clrbit(m_ccpx_con + CCPXCON2, ICS_CLR<<ICS_SHIFT);
   Reg::setbit(m_ccpx_con + CCPXCON2, e<<ICS_SHIFT);
}

//=============================================================================
    void        Ccp::pwm_restart        (bool tf)
//=============================================================================
{
   Reg::setbit(m_ccpx_con + CCPXCON2, PWMRSEN, tf);
}

//=============================================================================
    void        Ccp::gate_auto          (bool tf)
//=============================================================================
{
   Reg::setbit(m_ccpx_con + CCPXCON2, ASDGM, tf);
}

//=============================================================================
    void        Ccp::gate_now           (bool tf)
//=============================================================================
{
   Reg::setbit(m_ccpx_con + CCPXCON2, SSDG, tf);
}

//=============================================================================
    void        Ccp::gate_autosrc       (GATEAUTOSRC e)
//=============================================================================
{
   Reg::val((vu8ptr)m_ccpx_con + (CCPXCON2 * 4), e);
}

//ccpxcon3
//=============================================================================
    void        Ccp::out_trigwait       (bool tf)
//=============================================================================
{
    Reg::setbit(m_ccpx_con + CCPXCON3, OETRIG, tf);
}

//=============================================================================
    void        Ccp::oneshot_extend     (uint8_t v)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con + CCPXCON3, OSCNT_CLR<<OSCNT_SHIFT);
    Reg::setbit(m_ccpx_con + CCPXCON3, (v bitand OSCNT_CLR)<<OSCNT_SHIFT);
}

//=============================================================================
    void        Ccp::out_mode           (OUTM e)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con + CCPXCON3, OUTM_CLR<<OUTM_SHIFT);
    Reg::setbit(m_ccpx_con + CCPXCON3, e<<OUTM_SHIFT);
}

//=============================================================================
    void        Ccp::polarity_ace       (POLARITY e)
//=============================================================================
{
    Reg::setbit(m_ccpx_con + CCPXCON3, POLACE, e);
}

//=============================================================================
    void        Ccp::polarity_bdf       (POLARITY e)
//=============================================================================
{
    Reg::setbit(m_ccpx_con + CCPXCON3, POLBDF, e);
}

//=============================================================================
    void        Ccp::shutdown_ace       (SHUTDOWN e)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con + CCPXCON3, PSSACE_CLR<<PSSACE_SHIFT);
    Reg::setbit(m_ccpx_con + CCPXCON3, e<<PSSACE_SHIFT);
}

//=============================================================================
    void        Ccp::shutdown_bdf       (SHUTDOWN e)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con + CCPXCON3, PSSBDF_CLR<<PSSBDF_SHIFT);
    Reg::setbit(m_ccpx_con + CCPXCON3, e<<PSSBDF_SHIFT);
}

//=============================================================================
    void        Ccp::dead_time          (uint8_t v)
//=============================================================================
{
    Reg::clrbit(m_ccpx_con + CCPXCON3, DT_CLR<<DT_SHIFT);
    Reg::setbit(m_ccpx_con + CCPXCON3, (v bitand DT_CLR)<<DT_SHIFT);
}

//ccpxstat
//=============================================================================
    bool        Ccp::pr16_busy          ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, PRLWIP);
}

//=============================================================================
    bool        Ccp::tmr32_busy         ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, TMRHWIP);
}

//=============================================================================
    bool        Ccp::tmr16_busy         ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, TMRLWIP);
}

//=============================================================================
    bool        Ccp::compb_busy         ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, RBWIP);
}

//=============================================================================
    bool        Ccp::compa_busy         ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, RAWIP);
}

//=============================================================================
    void        Ccp::gate_arm           ()
//=============================================================================
{
     Reg::setbit(m_ccpx_con + CCPXSTAT, ICGARM);
}

//=============================================================================
    bool        Ccp::stat_trig          ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, CCPTRIG);
}

//=============================================================================
    void        Ccp::trig_set           ()
//=============================================================================
{
     Reg::setbit(m_ccpx_con + CCPXSTAT, TRSET);
}

//=============================================================================
    void        Ccp::trig_clr           ()
//=============================================================================
{
     Reg::setbit(m_ccpx_con + CCPXSTAT, TRCLR);
}

//=============================================================================
    bool        Ccp::stat_shutdown      ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, ASEVT);
}

//=============================================================================
    bool        Ccp::stat_secomp        ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, SCEVT);
}

//=============================================================================
    bool        Ccp::stat_capdis        ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, ICDIS);
}

//=============================================================================
    bool        Ccp::stat_oflow         ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, ICOV);
}

//=============================================================================
    bool        Ccp::stat_bufany        ()
//=============================================================================
{
    return Reg::anybit(m_ccpx_con + CCPXSTAT, ICBNE);
}

//ccpxtmr
//=============================================================================
    void        Ccp::tmr16              (uint16_t v)
//=============================================================================
{
    Reg::val(m_ccpx_con + CCPXTMR, v);
}

//=============================================================================
    void        Ccp::tmr16h             (uint16_t v)
//=============================================================================
{
    Reg::val((vu8ptr)m_ccpx_con + (CCPXTMR * 4) + 2, v);
}

//=============================================================================
    void        Ccp::tmr32              (uint32_t v)
//=============================================================================
{
    Reg::val(m_ccpx_con + CCPXTMR, v);
}

//=============================================================================
    uint16_t    Ccp::tmr16              ()
//=============================================================================
{
    return Reg::val16(m_ccpx_con + CCPXTMR);
}

//=============================================================================
    uint16_t    Ccp::tmr16h             ()
//=============================================================================
{
    return Reg::val16((vu8ptr)m_ccpx_con + (CCPXTMR * 4) + 2);
}

//=============================================================================
    uint32_t    Ccp::tmr32              ()
//=============================================================================
{
    return Reg::val(m_ccpx_con + CCPXTMR);
}

//ccpxpr
//=============================================================================
    void        Ccp::pr16               (uint16_t v)
//=============================================================================
{
    Reg::val(m_ccpx_con + CCPXPR, v);
}

//=============================================================================
    void        Ccp::pr16h              (uint16_t v)
//=============================================================================
{
    Reg::val((vu8ptr)m_ccpx_con + (CCPXPR * 4) + 2, v);
}

//=============================================================================
    void        Ccp::pr32               (uint32_t v)
//=============================================================================
{
    Reg::val(m_ccpx_con + CCPXPR, v);
}

//=============================================================================
    uint16_t    Ccp::pr16               ()
//=============================================================================
{
    return Reg::val16(m_ccpx_con + CCPXPR);
}

//=============================================================================
    uint16_t    Ccp::pr16h              ()
//=============================================================================
{
    return Reg::val16((vu8ptr)m_ccpx_con + (CCPXPR * 4) + 2);
}

//=============================================================================
    uint32_t    Ccp::pr32               ()
//=============================================================================
{
    return Reg::val(m_ccpx_con + CCPXPR);
}

//ccpxra, ccpxrb
//=============================================================================
    void        Ccp::compa              (uint16_t v)
//=============================================================================
{
    Reg::val(m_ccpx_con + CCPXRA, v);
}

//=============================================================================
    void        Ccp::compb              (uint16_t v)
//=============================================================================
{
    Reg::val(m_ccpx_con + CCPXRB, v);
}

//=============================================================================
    void        Ccp::comp32             (uint32_t v)
//=============================================================================
{
    compb(v >> 16);
    compa(v);
}

//=============================================================================
    uint16_t    Ccp::compa              ()
//=============================================================================
{
    return Reg::val16(m_ccpx_con + CCPXRA);
}

//=============================================================================
    uint16_t    Ccp::compb              ()
//=============================================================================
{
    return Reg::val16(m_ccpx_con + CCPXRB);
}

//=============================================================================
    uint32_t    Ccp::comp32             ()
//=============================================================================
{
    return compb()<<16 | compa();
}

//ccpxbuf
//=============================================================================
    uint16_t    Ccp::buf16              ()
//=============================================================================
{
    return Reg::val16(m_ccpx_con + CCPXBUF);
}

//=============================================================================
    uint32_t    Ccp::buf32              ()
//=============================================================================
{
    return Reg::val(m_ccpx_con + CCPXBUF);
}

//misc
//=============================================================================
    uint8_t     Ccp::ccp_num            ()
//=============================================================================
{
    return ((uint32_t)m_ccpx_con - CCP1CON1) / (CCPX_SPACING * 4)  +  1;
}
